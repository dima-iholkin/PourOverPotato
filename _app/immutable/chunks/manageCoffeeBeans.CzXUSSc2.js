import{o as L,q as M}from"./index.DHsbL8_X.js";import{r as R}from"./scheduler.Cw1-ZcKD.js";import{o as u,C as f,b,c as j,R as l,d as g,e as O,f as T}from"./dateHelpers.DtGJLfnR.js";function $(e){return(e==null?void 0:e.length)!==void 0?e:Array.from(e)}function q(e,o){e.d(1),o.delete(e.key)}function k(e,o){L(e,1,1,()=>{o.delete(e.key)})}function J(e,o){e.f(),k(e,o)}function z(e,o,n,t,s,i,r,I,A,v,D,F){let w=e.length,m=i.length,C=w;const E={};for(;C--;)E[e[C].key]=C;const B=[],h=new Map,S=new Map,N=[];for(C=m;C--;){const a=F(s,i,C),c=n(a);let d=r.get(c);d?t&&N.push(()=>d.p(a,o)):(d=v(c,a),d.c()),h.set(c,B[C]=d),c in E&&S.set(c,Math.abs(C-E[c]))}const x=new Set,_=new Set;function p(a){M(a,1),a.m(I,D),r.set(a.key,a),D=a.first,m--}for(;w&&m;){const a=B[m-1],c=e[w-1],d=a.key,y=c.key;a===c?(D=a.first,w--,m--):h.has(y)?!r.has(d)||x.has(d)?p(a):_.has(y)?w--:S.get(d)>S.get(y)?(_.add(d),p(a)):(x.add(y),w--):(A(c,r),w--)}for(;w--;){const a=e[w];h.has(a.key)||A(a,r)}for(;m;)p(B[m-1]);return R(N),B}async function G(e){const n=(await u()).transaction(f,"readwrite").objectStore(f);if(await n.index("nameLowerCase").get(e.name.toLowerCase()))return"Failure_NameAlreadyExist";const s=new T(e);try{const i=await n.add(s);return await n.transaction.done,new b({...s,id:i}).toCoffeeBeans()}catch(i){if(i instanceof DOMException&&i.name==="ConstraintError"){const r=`A ConstraintError occurred while saving CoffeeBeans "${e.name}" to the database.
         It seems a CoffeeBeans with the same name already exist.`;return console.error(r,i),"Failure_NameAlreadyExist"}else return console.error(i),"DatabaseError"}}async function H(){return await(await u()).count(f)>0}async function K(e){const n=(await u()).transaction(f,"readwrite").objectStore(f),t=await n.get(e.id);if(t===void 0)return console.error(`The edited CoffeeBeans item ${JSON.stringify(e)} wasn't found in the database. Edit operation aborted.`),"CoffeeBeansNotFound";if(e.name.toLowerCase()!==t.nameLowerCase&&await n.index(j).get(e.name.toLowerCase()))return await n.transaction.done,"Failure_NameAlreadyExist";const s=new b({...e,nameLowerCase:e.name.toLowerCase(),softDeleted:!1});return await n.put(s),await n.transaction.done,new O(s)}async function Q(){return(await(await u()).getAll(f)).filter(t=>t.softDeleted===void 0||t.softDeleted===!1).map(t=>new b(t).toCoffeeBeans())}async function U(e){const n=await(await u()).get(f,e);if(!(n===void 0||n.softDeleted&&n.softDeleted===!0))return new b(n).toCoffeeBeans()}async function V(e){const n=await(await u()).getFromIndex(f,j,e.toLowerCase());if(!(n===void 0||n.softDeleted&&n.softDeleted===!0))return new b(n).toCoffeeBeans()}async function Y(e){let o=0;const t=(await u()).transaction([f,l],"readwrite"),s=await t.objectStore(l).index(g).getAll(e);for(const i of s)await t.objectStore(l).delete(i.id),o++;return t.objectStore(f).delete(e),await t.done,{coffeeBeansCount:1,recipesCount:o}}async function Z(e){let o=0;const t=(await u()).transaction([f,l],"readwrite"),s=await t.objectStore(f).get(e);if(s===void 0)return await t.done,"CoffeeBeansNotFound";const i=await t.objectStore(l).index(g).getAll(e);for(const r of i)r.softDeleted||(r.softDeleted=!0,await t.objectStore(l).put(r),o++);return s.softDeleted=!0,t.objectStore(f).put(s),await t.done,{coffeeBeansCount:1,recipesCount:o}}async function ee(e){let o=0;const t=(await u()).transaction([f,l],"readwrite"),s=await t.objectStore(f).get(e);if(s===void 0)return await t.done,"CoffeeBeansNotFound";s.softDeleted=!1,t.objectStore(f).put(s);const i=await t.objectStore(l).index(g).getAll(e);for(const r of i)r.softDeleted!==!1&&(r.softDeleted=!1,await t.objectStore(l).put(r),o++);return await t.done,{coffeeBeansCount:1,recipesCount:o}}export{H as a,U as b,K as c,V as d,$ as e,ee as f,Q as g,Y as h,q as i,G as j,J as k,k as o,Z as s,z as u};
