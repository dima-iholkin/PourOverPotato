var $=Object.defineProperty;var K=(t,e,n)=>e in t?$(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var i=(t,e,n)=>(K(t,typeof e!="symbol"?e+"":e,n),n);const I=(t,e)=>e.some(n=>t instanceof n);let E,A;function q(){return E||(E=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function z(){return A||(A=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const C=new WeakMap,b=new WeakMap,y=new WeakMap;function G(t){const e=new Promise((n,s)=>{const o=()=>{t.removeEventListener("success",r),t.removeEventListener("error",d)},r=()=>{n(p(t.result)),o()},d=()=>{s(t.error),o()};t.addEventListener("success",r),t.addEventListener("error",d)});return y.set(e,t),e}function J(t){if(C.has(t))return;const e=new Promise((n,s)=>{const o=()=>{t.removeEventListener("complete",r),t.removeEventListener("error",d),t.removeEventListener("abort",d)},r=()=>{n(),o()},d=()=>{s(t.error||new DOMException("AbortError","AbortError")),o()};t.addEventListener("complete",r),t.addEventListener("error",d),t.addEventListener("abort",d)});C.set(t,e)}let T={get(t,e,n){if(t instanceof IDBTransaction){if(e==="done")return C.get(t);if(e==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return p(t[e])},set(t,e,n){return t[e]=n,!0},has(t,e){return t instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in t}};function N(t){T=t(T)}function U(t){return z().includes(t)?function(...e){return t.apply(v(this),e),p(this.request)}:function(...e){return p(t.apply(v(this),e))}}function X(t){return typeof t=="function"?U(t):(t instanceof IDBTransaction&&J(t),I(t,q())?new Proxy(t,T):t)}function p(t){if(t instanceof IDBRequest)return G(t);if(b.has(t))return b.get(t);const e=X(t);return e!==t&&(b.set(t,e),y.set(e,t)),e}const v=t=>y.get(t);function H(t,e,{blocked:n,upgrade:s,blocking:o,terminated:r}={}){const d=indexedDB.open(t,e),a=p(d);return s&&d.addEventListener("upgradeneeded",c=>{s(p(d.result),c.oldVersion,c.newVersion,p(d.transaction),c)}),n&&d.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),a.then(c=>{r&&c.addEventListener("close",()=>r()),o&&c.addEventListener("versionchange",l=>o(l.oldVersion,l.newVersion,l))}).catch(()=>{}),a}const Q=["get","getKey","getAll","getAllKeys","count"],Y=["put","add","delete","clear"],D=new Map;function L(t,e){if(!(t instanceof IDBDatabase&&!(e in t)&&typeof e=="string"))return;if(D.get(e))return D.get(e);const n=e.replace(/FromIndex$/,""),s=e!==n,o=Y.includes(n);if(!(n in(s?IDBIndex:IDBObjectStore).prototype)||!(o||Q.includes(n)))return;const r=async function(d,...a){const c=this.transaction(d,o?"readwrite":"readonly");let l=c.store;return s&&(l=l.index(a.shift())),(await Promise.all([l[n](...a),o&&c.done]))[0]};return D.set(e,r),r}N(t=>({...t,get:(e,n,s)=>L(e,n)||t.get(e,n,s),has:(e,n)=>!!L(e,n)||t.has(e,n)}));const Z=["continue","continuePrimaryKey","advance"],x={},S=new WeakMap,F=new WeakMap,ee={get(t,e){if(!Z.includes(e))return t[e];let n=x[e];return n||(n=x[e]=function(...s){S.set(this,F.get(this)[e](...s))}),n}};async function*te(...t){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...t)),!e)return;e=e;const n=new Proxy(e,ee);for(F.set(n,e),y.set(n,v(e));e;)yield n,e=await(S.get(n)||e.continue()),S.delete(n)}function M(t,e){return e===Symbol.asyncIterator&&I(t,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&I(t,[IDBIndex,IDBObjectStore])}N(t=>({...t,get(e,n,s){return M(e,n)?te:t.get(e,n,s)},has(e,n){return M(e,n)||t.has(e,n)}}));class R{constructor(e,n){i(this,"id");i(this,"name");i(this,"description");this.id=n,this.name=e.name,this.description=e.description}}class W{constructor(e){i(this,"name");i(this,"description");this.name=e.name,this.description=e.description}static create(e){const n=e.name.trim(),s=e.description.trim();if(n.length<3)return"ValidationFailed_NameMustBeAtLeast3CharsLong";const o={name:n,description:s};return new W(o)}}class V{constructor(e){i(this,"id");i(this,"name");i(this,"description");this.id=e.id,this.name=e.name,this.description=e.description}static create(e){const n=e.name.trim(),s=e.description.trim();if(n.length<3)return"ValidationFailed_NameMustBeAtLeast3CharsLong";const o={id:e.id,name:n,description:s};return new V(o)}}class P{constructor(e,n){i(this,"id");i(this,"coffeeBeansId");i(this,"recipeTarget");i(this,"recipeResult");i(this,"recipeThoughts");i(this,"favorite");i(this,"rating");i(this,"outWeight");i(this,"timestamp");this.id=n,this.coffeeBeansId=e.coffeeBeansId,this.recipeTarget=e.recipeTarget,this.recipeResult=e.recipeResult,this.recipeThoughts=e.recipeThoughts,this.favorite=e.favorite,this.rating=e.rating,this.outWeight=e.outWeight,this.timestamp=e.timestamp}}function le(t){const e=t.getTimezoneOffset()*6e4;return new Date(t.getTime()-e).toISOString().slice(0,-8)}function ne(t){const e=Date.parse(t);return new Date(e)}function me(t){const e=Math.floor((Date.now()-t.getTime())/1e3);if(Math.floor(e/86400)>=1){const r=new Date;return r.setDate(r.getDate()-1),r.toDateString()===t.toDateString()?"yesterday":t.toLocaleString(void 0,{dateStyle:"short"})}const s=Math.floor(e/3600);if(s>1)return s+" hours ago";if(s===1)return"1 hour ago";const o=Math.floor(e/60);return o>1?o+" minutes ago":"just now"}function se(t){const e=new CustomEvent("addToast",{detail:{message:t,timeout:5e3}});document.dispatchEvent(e)}function he(t,e,n){const s=new CustomEvent("addToast",{detail:{message:t,timeout:1e4,onClickUndo:e,onUndoIgnored:n}});document.dispatchEvent(s)}class w{constructor(e,n){i(this,"id");i(this,"name");i(this,"description");i(this,"nameLowerCase");i(this,"softDeleted");this.id=n,this.name=e.name,this.description=e.description,this.nameLowerCase=e.nameLowerCase,this.softDeleted=e.softDeleted}toCoffeeBeans(){return new R(this,this.id)}}class oe{constructor(e){i(this,"name");i(this,"description");i(this,"nameLowerCase");i(this,"softDeleted");this.name=e.name,this.description=e.description,this.nameLowerCase=e.name.toLowerCase(),this.softDeleted=!1}}class h{constructor(e,n){i(this,"id");i(this,"coffeeBeansId");i(this,"recipeTarget");i(this,"recipeResult");i(this,"recipeThoughts");i(this,"favorite");i(this,"rating");i(this,"outWeight");i(this,"timestamp");i(this,"softDeleted");this.id=n,this.coffeeBeansId=e.coffeeBeansId,this.recipeTarget=e.recipeTarget,this.recipeResult=e.recipeResult,this.recipeThoughts=e.recipeThoughts,this.favorite=e.favorite,this.rating=e.rating,this.outWeight=e.outWeight,this.timestamp=e.timestamp,this.softDeleted=e.softDeleted}toRecipe(){const e={coffeeBeansId:this.coffeeBeansId,recipeTarget:this.recipeTarget,recipeResult:this.recipeResult,recipeThoughts:this.recipeThoughts,favorite:this.favorite,rating:this.rating,outWeight:this.outWeight,timestamp:new Date(this.timestamp)};return new P(e,this.id)}}class ie{constructor(e){i(this,"coffeeBeansId");i(this,"recipeTarget");i(this,"recipeResult");i(this,"recipeThoughts");i(this,"favorite");i(this,"rating");i(this,"outWeight");i(this,"timestamp");i(this,"softDeleted");this.coffeeBeansId=e.coffeeBeansId,this.recipeTarget=e.recipeTarget,this.recipeResult=e.recipeResult,this.recipeThoughts=e.recipeThoughts,this.favorite=e.favorite,this.rating=e.rating,this.outWeight=e.outWeight,this.timestamp=e.timestamp.getTime(),this.softDeleted=!1}}const ae="entities",g=2,m="coffeeBeans",B="nameLowerCase",f="recipes";async function u(){return await H(ae,g,{async upgrade(t,e,n,s){switch(e){case 0:j(t);break;case 1:{j(t),await re(t,s);break}}}})}function j(t){if(t.objectStoreNames.contains(m)===!1&&t.createObjectStore(m,{keyPath:"id",autoIncrement:!0}).createIndex(B,B,{unique:!0}),t.objectStoreNames.contains(f)===!1){const e=t.createObjectStore(f,{keyPath:"id",autoIncrement:!0});e.createIndex("coffeeBeansId","coffeeBeansId",{unique:!1}),e.createIndex("outWeight","outWeight",{unique:!1}),e.createIndex("rating","rating",{unique:!1}),e.createIndex("timestamp","timestamp",{unique:!1})}}async function re(t,e){const n=await e.objectStore(f).getAll();for(const s of n){const o={...s,favorite:!1,timestamp:s.timestamp.getTime()};await e.objectStore(f).put(o)}}async function ce(t){if(await fe(t.name)!==void 0)return"Failure_NameAlreadyExist";const n=new oe(t);try{const o=await(await u()).add(m,n);return new w(n,o).toCoffeeBeans()}catch(s){if(s instanceof DOMException&&s.name==="ConstraintError")return console.error(`A ConstraintError occurred while saving coffee beans "${t.name}" to the database.`),"Failure_NameAlreadyExist";throw s}}async function de(t){const e=await u(),n=new ie(t),s=await e.add(f,n);return new h(n,s).toRecipe()}async function pe(){return await(await u()).count(m)>0}async function we(){return await(await u()).count(f)>0}async function ge(){const t=await u(),e=IDBKeyRange.bound(Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER);await t.delete(m,e),await t.delete(f,e)}async function Be(t,e,n){const s=await u();if(e&&e===!0){if(n===void 0)throw new Error("If the argument softDelete: true, you must pass in the CoffeeBeans entity too.");const o={...n,nameLowerCase:n.name.toLowerCase(),softDeleted:!0},r=new w(o,n.id);await s.put(m,r);return}await s.delete(m,t)}async function ye(t,e,n){const s=await u();if(e&&e===!0){if(n===void 0)throw new Error("If the argument softDelete: true, you must pass in the Recipe entity too.");const o={...n,timestamp:n.timestamp.getTime(),softDeleted:!0},r=new h(o,n.id);await s.put(f,r);return}await s.delete(f,t)}async function be(t,e){const n=await u(),s=await n.getAllFromIndex(f,"coffeeBeansId",t);if(e&&e===!0){for(const o of s)o.softDeleted=!0,await n.put(f,o);return s.length}for(const o of s)await n.delete(f,o.id);return s.length}async function De(t){const e=await u(),n=await e.getFromIndex(m,B,t.name.toLowerCase());if(n!==void 0&&n.id!==t.id)return"Failure_NameAlreadyExist";const s={id:t.id,name:t.name,description:t.description,nameLowerCase:t.name.toLowerCase()};await e.put(m,s);const o={name:s.name,description:s.description};return new R(o,s.id)}async function Ie(t){const e=await u(),n={...t,timestamp:t.timestamp.getTime()},s=new h(n,t.id);return await e.put(f,s),s.toRecipe()}async function Ce(){const t={dbVersion:g,coffeeBeans:await _(),recipes:await O()},e=JSON.stringify(t);return new Blob([e],{type:"application/json"})}async function _(){return(await(await u()).getAll(m)).filter(s=>s.softDeleted===void 0||s.softDeleted===!1).map(s=>new w(s,s.id).toCoffeeBeans())}async function O(){return(await(await u()).getAll(f)).filter(s=>s.softDeleted===void 0||s.softDeleted===!1).map(s=>new h(s,s.id).toRecipe())}async function Te(t){const n=await(await u()).get(m,t);if(!(n===void 0||n.softDeleted&&n.softDeleted===!0))return new w(n,n.id).toCoffeeBeans()}async function fe(t){const n=await(await u()).getFromIndex(m,B,t.toLowerCase());if(!(n===void 0||n.softDeleted&&n.softDeleted===!0))return new w(n,n.id).toCoffeeBeans()}async function ve(t){const n=await(await u()).get(f,t);if(!(n===void 0||n.softDeleted&&n.softDeleted===!0))return new h(n,n.id).toRecipe()}async function Se(t){return(await(await u()).getAllFromIndex(f,"coffeeBeansId",t)).filter(o=>o.softDeleted===void 0||o.softDeleted===!1).map(o=>new h(o,o.id).toRecipe())}async function Re(t){const e=JSON.parse(await t.text());if(e.dbVersion===void 0){alert("dbVersion property not found in the file.");return}if(e.dbVersion===0){alert("The file's dbVersion cannot be 0.");return}if(e.dbVersion>g){alert(`The file's dbVersion "${g}" is newer than the current dbVersion.
       Try refreshing the page and importing again. If the issue persists, please contact the developer.`);return}if(e.coffeeBeans===void 0||Array.isArray(e.coffeeBeans)===!1){alert("coffeeBeans array not found.");return}if(e.recipes===void 0||Array.isArray(e.recipes)===!1){alert("recipes array not found.");return}const n=new Map,s=await _();let o=0;for(let a of e.coffeeBeans){a=new R(a,a.id);const c=s.find(k=>k.name.toLowerCase()===a.name.toLowerCase());if(c!==void 0&&c.id===a.id){n.set(a.id,c.id);continue}else if(c!==void 0){n.set(a.id,c.id);continue}const l=await ce(a);if(l==="Failure_NameAlreadyExist")throw alert("Failure_NameAlreadyExist error during importing CoffeeBeans. This shouldn't be possible, sorry. Contact the developer, I guess."),new Error("Failure_NameAlreadyExist");n.set(a.id,l.id),o++}const r=await O();let d=0;for(let a of e.recipes){if(a.timestamp=ne(a.timestamp),a=new P(a,a.id),n.has(a.coffeeBeansId)===!1)throw alert(`Could not find a correct CoffeeBeansId for imported recipe with Id ${a.id}. Sorry, something went wrong.`),new Error("Could not find a correct CoffeeBeansId for an imported recipe.");a.coffeeBeansId=n.get(a.coffeeBeansId),r.find(l=>l.timestamp.getTime()===a.timestamp.getTime()&&l.outWeight===a.outWeight&&l.rating===a.rating&&l.recipeTarget===a.recipeTarget&&l.recipeResult===a.recipeResult&&l.recipeThoughts===a.recipeThoughts&&l.coffeeBeansId===a.coffeeBeansId)===void 0&&(await de(a),d++)}se(`Imported ${o} coffee beans and ${d} recipes.`)}async function Ee(t){const e=await u(),n={...t,nameLowerCase:t.name.toLowerCase(),softDeleted:!1},s=new w(n,t.id);await e.put(m,s)}async function Ae(t){const e=await u(),n={...t,timestamp:t.timestamp.getTime(),softDeleted:!1},s=new h(n,t.id);await e.put(f,s)}async function Le(t){const e=await u(),n=await e.getAllFromIndex(f,"coffeeBeansId",t);for(const s of n){const o={...s,softDeleted:!1},r=new h(o,s.id);await e.put(f,r)}}export{Ce as A,Re as B,R as C,u as D,P as R,O as a,ve as b,Te as c,ye as d,he as e,le as f,_ as g,Ie as h,se as i,de as j,Se as k,V as l,De as m,fe as n,be as o,ne as p,Be as q,Ee as r,Le as s,ce as t,Ae as u,pe as v,we as w,me as x,W as y,ge as z};
