import{j as u,o as c,R as o,k as d,d as f}from"./dateHelpers.DtGJLfnR.js";import{s as p,d as m,u as b,g as w,e as _}from"./scheduler.Cw1-ZcKD.js";import{S as D,i as R,e as y,c as S,a as g,d as l,z as h,g as B,q as E,o as I}from"./index.DHsbL8_X.js";async function F(a){const t=new u(a),n=await(await c()).add(o,t);return new d({...t,id:n}).toRecipe()}async function P(){return await(await c()).count(o)>0}async function j(a){const t=d.fromRecipe(a);return await(await c()).put(o,t),t.toRecipe()}async function q(){return(await(await c()).getAll(o)).filter(n=>n.softDeleted===void 0||n.softDeleted===!1).map(n=>new d(n).toRecipe())}async function H(a){const e=await(await c()).get(o,a);if(!(e===void 0||e.softDeleted&&e.softDeleted===!0))return new d(e).toRecipe()}async function M(a){return(await(await c()).getAllFromIndex(o,f,a)).filter(s=>s.softDeleted===void 0||s.softDeleted===!1).map(s=>new d(s).toRecipe())}async function O(a){await(await c()).delete(o,a)}async function k(a){const e=(await c()).transaction(o,"readwrite").objectStore(o),n=await e.get(a);return n===void 0?"RecipeNotFound":(n.softDeleted=!0,await e.put(n),await e.transaction.done,"Success")}async function z(a){const e=(await c()).transaction(o,"readwrite").objectStore(o),n=await e.get(a);return n===void 0?"RecipeNotFound":(n.softDeleted=!1,await e.put(n),await e.transaction.done,"Success")}function v(a){let t,e;const n=a[1].default,s=m(n,a,a[0],null);return{c(){t=y("h1"),s&&s.c(),this.h()},l(i){t=S(i,"H1",{class:!0});var r=g(t);s&&s.l(r),r.forEach(l),this.h()},h(){h(t,"class","svelte-137mtb2")},m(i,r){B(i,t,r),s&&s.m(t,null),e=!0},p(i,[r]){s&&s.p&&(!e||r&1)&&b(s,n,i,i[0],e?_(n,i[0],r,null):w(i[0]),null)},i(i){e||(E(s,i),e=!0)},o(i){I(s,i),e=!1},d(i){i&&l(t),s&&s.d(i)}}}function $(a,t,e){let{$$slots:n={},$$scope:s}=t;return a.$$set=i=>{"$$scope"in i&&e(0,s=i.$$scope)},[s,n]}class T extends D{constructor(t){super(),R(this,t,$,v,p,{})}}export{T as P,P as a,H as b,F as c,M as d,j as e,q as g,O as h,k as s,z as u};
