import{o as R,q as L}from"./index.DHsbL8_X.js";import{r as O}from"./scheduler.Cw1-ZcKD.js";import{o as l,C as s,b,c as I,R as u,d as j,E as D,e as M,f as W}from"./toastProvider.CA3wvqVI.js";function H(e){return(e==null?void 0:e.length)!==void 0?e:Array.from(e)}function J(e,o){e.d(1),o.delete(e.key)}function k(e,o){R(e,1,1,()=>{o.delete(e.key)})}function $(e,o){e.f(),k(e,o)}function z(e,o,n,t,a,c,f,d,v,x,E,F){let w=e.length,C=c.length,p=w;const h={};for(;p--;)h[e[p].key]=p;const B=[],y=new Map,T=new Map,A=[];for(p=C;p--;){const i=F(a,c,p),r=n(i);let m=f.get(r);m?t&&A.push(()=>m.p(i,o)):(m=x(r,i),m.c()),y.set(r,B[p]=m),r in h&&T.set(r,Math.abs(p-h[r]))}const N=new Set,_=new Set;function g(i){L(i,1),i.m(d,E),f.set(i.key,i),E=i.first,C--}for(;w&&C;){const i=B[C-1],r=e[w-1],m=i.key,S=r.key;i===r?(E=i.first,w--,C--):y.has(S)?!f.has(m)||N.has(m)?g(i):_.has(S)?w--:T.get(m)>T.get(S)?(_.add(m),g(i)):(N.add(S),w--):(v(r,f),w--)}for(;w--;){const i=e[w];y.has(i.key)||v(i,f)}for(;C;)g(B[C-1]);return O(A),B}async function G(e){const n=(await l()).transaction([s,D],"readwrite");if(await n.objectStore(s).index("nameLowerCase").get(e.name.toLowerCase()))return"Failure_NameAlreadyExist";const a=new W(e),c=await n.objectStore(s).add(a),f={id:c,recipesCount:0,earliestRecipeTimestamp:void 0,latestRecipeTimestamp:void 0};return await n.objectStore(D).add(f),await n.done,new b({...a,id:c}).toCoffeeBeans()}async function K(){return await(await l()).count(s)>0}async function Q(e){const n=(await l()).transaction(s,"readwrite"),t=await n.objectStore(s).get(e.id);if(t===void 0)return console.error(`The edited CoffeeBeans item ${JSON.stringify(e)} wasn't found in the database. Edit operation aborted.`),"CoffeeBeansNotFound";if(e.name.toLowerCase()!==t.nameLowerCase&&await n.objectStore(s).index(I).get(e.name.toLowerCase()))return await n.done,"Failure_NameAlreadyExist";const a=new b({...e,nameLowerCase:e.name.toLowerCase(),softDeletionTimestamp:void 0});return await n.objectStore(s).put(a),await n.done,new M(a)}async function U(){return(await(await l()).getAll(s)).filter(t=>t.softDeletionTimestamp===void 0).map(t=>new b(t).toCoffeeBeans())}async function V(e){const n=await(await l()).get(s,e);if(!(n===void 0||n.softDeletionTimestamp))return new b(n).toCoffeeBeans()}async function Y(e){const n=await(await l()).getFromIndex(s,I,e.toLowerCase());if(!(n===void 0||n.softDeletionTimestamp))return new b(n).toCoffeeBeans()}async function Z(e){let o=0;const t=(await l()).transaction([s,u,D],"readwrite"),a=await t.objectStore(u).index(j).getAll(e);for(const c of a)await t.objectStore(u).delete(c.id),o++;return t.objectStore(s).delete(e),t.objectStore(D).delete(e),await t.done,{coffeeBeansCount:1,recipesCount:o}}async function ee(e){let o=0;const t=(await l()).transaction([s,u],"readwrite"),a=await t.objectStore(s).get(e);if(a===void 0)return await t.done,"CoffeeBeansNotFound";const c=await t.objectStore(u).index(j).getAll(e),f=Date.now();for(const d of c)d.softDeletionTimestamp||(d.softDeletionTimestamp=f,await t.objectStore(u).put(d),o++);return a.softDeletionTimestamp=f,t.objectStore(s).put(a),await t.done,{coffeeBeansCount:1,recipesCount:o}}async function te(e){let o=0;const t=(await l()).transaction([s,u],"readwrite"),a=await t.objectStore(s).get(e);if(a===void 0)return await t.done,"CoffeeBeansNotFound";if(a.softDeletionTimestamp===void 0)return await t.done,{coffeeBeansCount:0,recipesCount:0};const c=a.softDeletionTimestamp;a.softDeletionTimestamp=void 0,t.objectStore(s).put(a);const f=await t.objectStore(u).index(j).getAll(e);for(const d of f)d.softDeletionTimestamp!==void 0&&(d.softDeletionTimestamp<c||(d.softDeletionTimestamp=void 0,await t.objectStore(u).put(d),o++));return await t.done,{coffeeBeansCount:1,recipesCount:o}}export{K as a,V as b,Q as c,Y as d,H as e,te as f,U as g,Z as h,J as i,G as j,$ as k,k as o,ee as s,z as u};
