import{o as R,q as L}from"./index.D7LFJCWc.js";import{r as O}from"./scheduler.Cw1-ZcKD.js";import{o as u,C as a,a as b,d as j,R as l,e as v,E as D,f as M,g as k}from"./core.C_szslgD.js";function H(e){return(e==null?void 0:e.length)!==void 0?e:Array.from(e)}function J(e,o){e.d(1),o.delete(e.key)}function W(e,o){R(e,1,1,()=>{o.delete(e.key)})}function $(e,o){e.f(),W(e,o)}function z(e,o,n,t,s,c,f,d,N,_,E,F){let w=e.length,C=c.length,p=w;const y={};for(;p--;)y[e[p].key]=p;const B=[],h=new Map,g=new Map,x=[];for(p=C;p--;){const i=F(s,c,p),r=n(i);let m=f.get(r);m?x.push(()=>m.p(i,o)):(m=_(r,i),m.c()),h.set(r,B[p]=m),r in y&&g.set(r,Math.abs(p-y[r]))}const A=new Set,I=new Set;function T(i){L(i,1),i.m(d,E),f.set(i.key,i),E=i.first,C--}for(;w&&C;){const i=B[C-1],r=e[w-1],m=i.key,S=r.key;i===r?(E=i.first,w--,C--):h.has(S)?!f.has(m)||A.has(m)?T(i):I.has(S)?w--:g.get(m)>g.get(S)?(I.add(m),T(i)):(A.add(S),w--):(N(r,f),w--)}for(;w--;){const i=e[w];h.has(i.key)||N(i,f)}for(;C;)T(B[C-1]);return O(x),B}async function G(e){const n=(await u()).transaction([a,D],"readwrite");if(await n.objectStore(a).index("nameLowerCase").get(e.name.toLowerCase()))return"Failure_NameAlreadyExist";const s=new k(e),c=await n.objectStore(a).add(s),f={id:c,recipesCount:0,earliestRecipeTimestamp:void 0,latestRecipeTimestamp:void 0};return await n.objectStore(D).add(f),await n.done,new b({...s,id:c}).toCoffeeBeans()}async function K(){return await(await u()).count(a)>0}async function Q(e){return await(await u()).transaction(a,"readwrite").objectStore(a).index(j).get(e.trim().toLowerCase())===void 0?"CoffeeBeansNotFound":"Failure_NameAlreadyExist"}async function U(e){const n=(await u()).transaction(a,"readwrite"),t=await n.objectStore(a).get(e.id);if(t===void 0)return console.error(`The edited CoffeeBeans item ${JSON.stringify(e)} wasn't found in the database. Edit operation aborted.`),"CoffeeBeansNotFound";if(e.name.toLowerCase()!==t.nameLowerCase&&await n.objectStore(a).index(j).get(e.name.toLowerCase()))return await n.done,"Failure_NameAlreadyExist";const s=new b({...e,nameLowerCase:e.name.toLowerCase(),softDeletionTimestamp:void 0});return await n.objectStore(a).put(s),await n.done,new M(s)}async function V(){return(await(await u()).getAll(a)).filter(t=>t.softDeletionTimestamp===void 0).map(t=>new b(t).toCoffeeBeans())}async function Y(e){const n=await(await u()).get(a,e);if(!(n===void 0||n.softDeletionTimestamp))return new b(n).toCoffeeBeans()}async function Z(e){const n=await(await u()).getFromIndex(a,j,e.toLowerCase());if(!(n===void 0||n.softDeletionTimestamp))return new b(n).toCoffeeBeans()}async function ee(e){let o=0;const t=(await u()).transaction([a,l,D],"readwrite"),s=await t.objectStore(l).index(v).getAll(e);for(const c of s)await t.objectStore(l).delete(c.id),o++;return t.objectStore(a).delete(e),t.objectStore(D).delete(e),await t.done,{coffeeBeansCount:1,recipesCount:o}}async function te(e){let o=0;const t=(await u()).transaction([a,l],"readwrite"),s=await t.objectStore(a).get(e);if(s===void 0)return await t.done,"CoffeeBeansNotFound";const c=await t.objectStore(l).index(v).getAll(e),f=Date.now();for(const d of c)d.softDeletionTimestamp||(d.softDeletionTimestamp=f,await t.objectStore(l).put(d),o++);return s.softDeletionTimestamp=f,t.objectStore(a).put(s),await t.done,{coffeeBeansCount:1,recipesCount:o}}async function ne(e){let o=0;const t=(await u()).transaction([a,l],"readwrite"),s=await t.objectStore(a).get(e);if(s===void 0)return await t.done,"CoffeeBeansNotFound";if(s.softDeletionTimestamp===void 0)return await t.done,{coffeeBeansCount:0,recipesCount:0};const c=s.softDeletionTimestamp;s.softDeletionTimestamp=void 0,t.objectStore(a).put(s);const f=await t.objectStore(l).index(v).getAll(e);for(const d of f)d.softDeletionTimestamp!==void 0&&(d.softDeletionTimestamp<c||(d.softDeletionTimestamp=void 0,await t.objectStore(l).put(d),o++));return await t.done,{coffeeBeansCount:1,recipesCount:o}}export{K as a,U as b,Q as c,Z as d,H as e,ne as f,V as g,ee as h,J as i,Y as j,G as k,$ as l,W as o,te as s,z as u};
